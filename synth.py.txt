import tkinter as tk
from tkinter import messagebox, filedialog
import sounddevice as sd
import numpy as np
import pygame
import threading
import time
import json
import copy
import sys
import torch  # GPU Acceleration

# Check for CUDA availability
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# MIDI Safe-Load
try:
    import mido
    MIDI_ENABLED = True
except ImportError:
    MIDI_ENABLED = False

# --- CONFIG ---
SAMPLE_RATE = 44100
sd.default.latency = 'low' 
WHITE, BLACK, GRAY, KNOB, NOTE, MIC = "#FFFFFF", "#000000", "#1E1E1E", "#00C8FF", "#00B4B4", "#FF6464"
ROOTS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
KEY_MAP = {'a': 60, 'w': 61, 's': 62, 'e': 63, 'd': 64, 'f': 65, 't': 66, 'g': 67, 'y': 68, 'h': 69, 'u': 70, 'j': 71, 'k': 72, 'o': 73, 'l': 74, 'p': 75, ';': 76}

def midi_to_freq(midi):
    return 440 * 2**((midi - 69) / 12)

def apply_lowpass(data, cutoff_freq):
    if cutoff_freq >= 20000: return data
    dt, RC = 1.0 / SAMPLE_RATE, 1.0 / (2 * np.pi * cutoff_freq)
    alpha = dt / (RC + dt)
    filtered = np.zeros_like(data)
    for i in range(1, len(data)): 
        filtered[i] = filtered[i-1] + (alpha * (data[i] - filtered[i-1]))
    return filtered

def generate_waveform(freq, dur, fade, mode, vol, filter_val=20000):
    t = np.linspace(0, dur, int(SAMPLE_RATE * dur), False)
    if mode == "Synth Bass":
        wf = (t * freq % 1) + (t * (freq * 1.005) % 1) - 1.0
        wf = apply_lowpass(wf, filter_val)
    elif mode == "Classic Strings":
        wf = (np.sin(2*np.pi*freq*t) + 0.5*np.sin(2*np.pi*(freq*1.01)*t))
    elif mode == "Electric Piano":
        wf = np.sin(2*np.pi*freq*t + np.sin(2*np.pi*freq*3*t)*8)
    elif mode == "Classic Piano":
        wf = np.sin(2*np.pi*freq*t) + 0.4*np.sin(2*np.pi*freq*2*t)
    elif mode == "Classic Synth":
        wf = np.sign(np.sin(2 * np.pi * freq * t)) * 0.3
    else: 
        wf = np.sin(2 * np.pi * freq * t)
    
    peak = np.max(np.abs(wf))
    wf = (wf / peak * vol) if peak > 0 else wf
    fs = int(SAMPLE_RATE * fade)
    if len(wf) > fs:
        wf[:fs] *= np.linspace(0, 1, fs)
        wf[-fs:] *= np.linspace(1, 0, fs)
    return wf.astype(np.float32)

def stft_pitch_shift(data, semitones):
    """GPU-Accelerated Phase-Locked Vocoder using PyTorch CUDA"""
    if semitones == 0 or len(data) < 1024: return data
    factor = 2.0**(semitones / 12.0)
    n_fft = 2048
    hop_length = n_fft // 4
    x = torch.from_numpy(data).to(DEVICE)
    window = torch.hann_window(n_fft).to(DEVICE)
    spec = torch.stft(x, n_fft, hop_length, window=window, return_complex=True)
    mag, phase = torch.abs(spec), torch.angle(spec)
    
    # Resizing spectral frames
    new_size = int(spec.shape[1] / factor)
    if new_size < 2: return data
    mag_resized = torch.nn.functional.interpolate(mag.unsqueeze(0), size=new_size, mode='linear', align_corners=False).squeeze(0)
    phase_resized = torch.nn.functional.interpolate(phase.unsqueeze(0), size=new_size, mode='linear', align_corners=False).squeeze(0)
    
    new_spec = torch.polar(mag_resized, phase_resized)
    y = torch.istft(new_spec, n_fft, hop_length, window=window)
    y_final = torch.nn.functional.interpolate(y.unsqueeze(0).unsqueeze(0), size=len(data), mode='linear', align_corners=False).squeeze()
    return y_final.cpu().numpy().astype(np.float32)

def apply_autotune(data, strength, active_scale_map, root_idx):
    """Robotic Hard-Tune Logic using STFT Shifting"""
    if strength < 0.01 or len(data) < 1024: return data, None
    sig = data[len(data)//4:len(data)//4+2048]
    zc = np.where(np.diff(np.sign(sig)))[0]
    if len(zc) < 2: return data, None
    freq = SAMPLE_RATE / (np.mean(np.diff(zc)) * 2)
    midi = 12 * np.log2(max(1e-9, freq) / 440.0) + 69
    allowed = [i for i, active in enumerate(active_scale_map) if active]
    if not allowed: return data, None
    octave = int(midi // 12)
    targets = [(octave + o)*12 + a + root_idx for a in allowed for o in [-1, 0, 1]]
    t_midi = min(targets, key=lambda x: abs(x - midi))
    shift_required = (t_midi - midi) * strength
    return stft_pitch_shift(data, shift_required), (t_midi - root_idx) % 12
class VoiceRecorderApp:
    def __init__(self, root):
        self.root = root
        self.root.title("PySynth Studio - GPU Pro")
        self.root.geometry("1500x950")
        self.root.configure(bg=BLACK)
        pygame.mixer.pre_init(SAMPLE_RATE, -16, 2, 2048)
        pygame.init()

        self.undo_stack, self.redo_stack, self.max_undo = [], [], 50
        self.played_cache = set()
        self.bpm, self.is_recording, self.playing, self.sequencer_recording = 120.0, False, False, False
        self.start_t, self.pause_elap, self.master_vol = 0, 0, 1.0
        self.modes = ["Sine", "Electric Piano", "Classic Synth", "Classic Strings", "Classic Piano", "Synth Bass"]
        self.q_options = {"OFF": 0, "1/4": 1.0, "1/8": 0.5, "1/16": 0.25, "1/32": 0.125}
        self.cur_q = tk.StringVar(value="OFF")
        self.tracks, self.active_track_idx, self.custom_scale = [], 0, [True] * 12
        self.scale_key_btns, self.knob_refs, self.knob_updates = {}, {}, {}
        self.knob_hovered = None
        self.selected_note = None
        self.drag_note = None
        self.drag_start_x = 0
        self.drag_start_dur = 0
        self.duplicate_note = None
        self.duplicate_after_id = None

        self._build_main_layout()
        self.add_track(False) 
        self._init_midi()
        
        self.root.bind("<KeyPress>", self.key_down)
        self.root.bind("<space>", lambda e: self.toggle_play())
        self.root.bind("<Control-z>", lambda e: self.undo())
        self.root.bind("<Control-Shift-Z>", lambda e: self.redo())
        self.root.bind("<Delete>", lambda e: self.delete_selected_notes())
        self.root.bind("<MouseWheel>", self._on_mousewheel)

        self.update_engine()

    def save_state(self):
        state = {'tracks': copy.deepcopy(self.tracks), 'active_track_idx': self.active_track_idx, 'custom_scale': list(self.custom_scale), 'master_vol': self.master_vol}
        self.undo_stack.append(state)
        if len(self.undo_stack) > self.max_undo: self.undo_stack.pop(0)
        self.redo_stack.clear()

    def undo(self):
        if not self.undo_stack: return
        self.redo_stack.append({'tracks': copy.deepcopy(self.tracks), 'active_track_idx': self.active_track_idx, 'custom_scale': list(self.custom_scale), 'master_vol': self.master_vol})
        s = self.undo_stack.pop()
        self.tracks, self.active_track_idx, self.custom_scale, self.master_vol = s['tracks'], s['active_track_idx'], s['custom_scale'], s['master_vol']
        self.refresh_track_ui(); self.refresh_keyboard_colors(); self.draw_sequencer(self.pause_elap)

    def redo(self):
        if not self.redo_stack: return
        self.undo_stack.append({'tracks': copy.deepcopy(self.tracks), 'active_track_idx': self.active_track_idx, 'custom_scale': list(self.custom_scale), 'master_vol': self.master_vol})
        s = self.redo_stack.pop()
        self.tracks, self.active_track_idx, self.custom_scale, self.master_vol = s['tracks'], s['active_track_idx'], s['custom_scale'], s['master_vol']
        self.refresh_track_ui(); self.refresh_keyboard_colors(); self.draw_sequencer(self.pause_elap)

    def update_engine(self):
        dur = self.get_loop_dur()
        now = (time.time()-self.start_t)%dur if self.playing else self.pause_elap
        if self.playing:
            lid = int((time.time()-self.start_t)//dur)
            for i, tr in enumerate(self.tracks):
                for n in tr['notes']:
                    if (i, n['t'], lid) not in self.played_cache and abs(n['t']-now) < 0.05:
                        self.played_cache.add((i, n['t'], lid))
                        if 'snd_raw' in n: 
                            raw = stft_pitch_shift(n['snd_raw'], tr['transpose'])
                        else: 
                            freq = midi_to_freq(n['m'] + int(tr['transpose']))
                            raw = generate_waveform(freq, n.get('d', 0.4), 0.1, self.modes[tr['ins_idx']], 1.0)
                        raw, _ = apply_autotune(raw, tr['tune'], self.custom_scale, 0)
                        snd = (np.column_stack((raw,raw)) * tr['vol'] * self.master_vol * 32767).astype(np.int16)
                        pygame.mixer.Sound(buffer=snd).play()
        if len(self.played_cache) > 1000: self.played_cache.clear()
        self.draw_sequencer(now); self.root.after(16, self.update_engine)
    def _build_main_layout(self):
        self.top_bar = tk.Frame(self.root, bg="#202020", height=80); self.top_bar.pack(side="top", fill="x")
        self.seq_btn = tk.Button(self.top_bar, text="PLAY", command=self.toggle_play, bg="#00C850", width=8); self.seq_btn.pack(side="left", padx=10)
        self.rec_btn = tk.Button(self.top_bar, text="REC PIANO", command=lambda: setattr(self, 'sequencer_recording', not self.sequencer_recording), bg="#444", fg="white"); self.rec_btn.pack(side="left", padx=10)
        tk.Button(self.top_bar, text="+ TRACK", command=lambda: self.add_track(False), bg="#333").pack(side="left", padx=5)
        tk.Button(self.top_bar, text="DUPE", command=self.duplicate_track, bg="#333").pack(side="left", padx=5)
        tk.Button(self.top_bar, text="DEL", command=self.remove_track, bg="#500").pack(side="left", padx=5)
        tk.OptionMenu(self.top_bar, self.cur_q, *self.q_options.keys()).pack(side="left", padx=5)
        self.create_custom_knob(self.top_bar, 'M', 'vol', "MASTER", 0, 2.0, "#FFD700")
        
        self.workspace = tk.Frame(self.root, bg="#121212"); self.workspace.pack(fill="both", expand=True)
        self.sidebar = tk.Frame(self.workspace, width=320, bg="#1E1E1E"); self.sidebar.pack(side="left", fill="y")
        self.track_canvas = tk.Canvas(self.sidebar, bg="#1E1E1E", highlightthickness=0); self.track_canvas.pack(side="left", fill="both", expand=True)
        self.track_inner = tk.Frame(self.track_canvas, bg="#1E1E1E"); self.track_canvas.create_window((0, 0), window=self.track_inner, anchor="nw")
        
        self.right_container = tk.Frame(self.workspace, bg="#121212"); self.right_container.pack(side="right", fill="both", expand=True)
        self.canvas = tk.Canvas(self.right_container, bg="#121212", highlightthickness=0); self.canvas.pack(fill="both", expand=True)
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        self.canvas.bind("<B1-Motion>", self.on_canvas_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_canvas_release)
        self.canvas.bind("<Button-3>", self.on_canvas_right_down)
        self.canvas.bind("<ButtonRelease-3>", self.on_canvas_right_up)
        self.canvas.bind("<MouseWheel>", self.on_canvas_scroll)
        self.bottom_piano_f = tk.Frame(self.root, bg=BLACK, height=150); self.bottom_piano_f.pack(side="bottom", fill="x")
        self._build_playable_piano(self.bottom_piano_f); self._build_scale_keys()

    def create_custom_knob(self, parent, idx, pk, label, vmin, vmax, color):
        f = tk.Frame(parent, bg="#222" if isinstance(idx, int) else "#202020"); f.pack(side="left", padx=10)
        tk.Label(f, text=label, bg=f.cget("bg"), fg="#888", font=("Arial", 7, "bold")).pack()
        c = tk.Canvas(f, width=42, height=42, bg=f.cget("bg"), highlightthickness=0); c.pack()
        val_lbl = tk.Label(f, text="0.0", bg=f.cget("bg"), fg="white", font=("Courier", 8)); val_lbl.pack()
        inf_min, inf_max = (vmin, vmax) if pk != "transpose" else (-128, 128)
        def draw(val):
            c.delete("all"); c.create_oval(4, 4, 38, 38, outline="#111", width=3)
            ext = -(((max(vmin, min(vmax, val)) - vmin) / (vmax - vmin)) * 270) % 360
            c.create_arc(4, 4, 38, 38, start=225, extent=ext, outline=color, width=3, style="arc")
            val_lbl.config(text=f"{val:.1f}")
        def update(delta):
            if idx != 'M' and (idx >= len(self.tracks)): return
            curr = self.master_vol if idx == 'M' else self.tracks[idx][pk]
            nv = max(inf_min, min(inf_max, curr + delta))
            if idx == 'M': self.master_vol = nv
            else: self.tracks[idx][pk] = nv
            draw(nv); self.draw_sequencer(self.pause_elap)
        c.bind("<Button-1>", lambda e: [setattr(self, 'ly', e.y), self.save_state()])
        c.bind("<B1-Motion>", lambda e: [update((self.ly - e.y) * ((vmax-vmin)/100)), setattr(self, 'ly', e.y)])
        c.bind("<Enter>", lambda e: setattr(self, 'knob_hovered', (idx, pk)))
        c.bind("<Leave>", lambda e: setattr(self, 'knob_hovered', None))
        self.knob_refs[(idx, pk)] = draw
        self.knob_updates[(idx, pk)] = update
        draw(self.master_vol if idx == 'M' else self.tracks[idx][pk])
    def trigger_note(self, m):
        if not self.tracks: return
        tr = self.tracks[self.active_track_idx]
        freq = midi_to_freq(m + int(tr['transpose']))
        raw = generate_waveform(freq, 0.4, 0.1, self.modes[tr['ins_idx']], tr['vol'])
        raw, _ = apply_autotune(raw, tr['tune'], self.custom_scale, 0)
        if self.sequencer_recording:
            self.save_state(); now = (time.time()-self.start_t)%self.get_loop_dur() if self.playing else self.pause_elap
            tr['notes'].append({'t': self.get_quantized_time(now), 'm': m, 'd': 0.4})
        pygame.mixer.Sound(buffer=(np.column_stack((raw,raw))*self.master_vol*32767).astype(np.int16)).play()

    def start_mic_recording(self):
        if self.is_recording or not self.tracks: return
        self.is_recording, self.recorded_audio = True, []
        def cb(i, f, t, s): self.recorded_audio.extend(i[:, 0].copy())
        self.stream = sd.InputStream(samplerate=SAMPLE_RATE, channels=1, callback=cb)
        self.stream.start(); self.rec_btn.config(text="STOP MIC", bg="#FF0000")

    def stop_mic_recording(self):
        if not self.is_recording or not self.tracks: return
        self.is_recording = False; self.stream.stop(); self.stream.close()
        if self.recorded_audio:
            self.save_state(); tr = self.tracks[self.active_track_idx]
            now = (time.time()-self.start_t)%self.get_loop_dur() if self.playing else self.pause_elap
            tr['notes'].append({'t': self.get_quantized_time(now), 'm': 60, 'd': len(self.recorded_audio)/SAMPLE_RATE, 'snd_raw': np.array(self.recorded_audio).astype(np.float32)})
        self.rec_btn.config(text="REC PIANO", bg="#444")

    def _init_midi(self):
        if not MIDI_ENABLED: return
        def worker():
            try:
                inputs = [mido.open_input(n) for n in mido.get_input_names()]
                while True:
                    for p in inputs:
                        for msg in p.iter_pending():
                            if msg.type == 'note_on' and msg.velocity > 0: self.root.after(0, lambda m=msg.note: self.trigger_note(m))
                    time.sleep(0.001)
            except: pass
        threading.Thread(target=worker, daemon=True).start()

    def get_loop_dur(self): return (60.0 / self.bpm) * 4.0
    def toggle_play(self):
        if self.playing:
            dur = self.get_loop_dur()
            self.pause_elap = (time.time() - self.start_t) % dur
            self.playing = False
            self.start_t = 0
            self.played_cache.clear()
        else:
            self.playing = True
            self.start_t = time.time() - self.pause_elap
            self.played_cache.clear()
        self.seq_btn.config(text="STOP" if self.playing else "PLAY", bg="#FF4444" if self.playing else "#00C850")
    def get_quantized_time(self, t):
        qv = self.q_options[self.cur_q.get()]; step = (60.0/self.bpm) * qv
        return round(t / step) * step if qv != 0 else t

    def _build_playable_piano(self, p):
        w_notes, b_notes = [60, 62, 64, 65, 67, 69, 71, 72, 74, 76], [61, 63, 66, 68, 70, 73, 75]
        for i, m in enumerate(w_notes): tk.Button(p, bg="white", text=ROOTS[m%12], command=lambda n=m: self.trigger_note(n)).place(x=i*50+20, y=30, width=48, height=110)
        for m in b_notes: tk.Button(p, bg="#222", fg="white", text=ROOTS[m%12], command=lambda n=m: self.trigger_note(n)).place(x=w_notes.index(m-1)*50+52, y=30, width=32, height=70)

    def _build_scale_keys(self):
        sf = tk.Frame(self.bottom_piano_f, bg=BLACK); sf.place(x=550, y=0)
        for i in range(12):
            btn = tk.Button(sf, text=ROOTS[i], font=("Arial", 7), width=3, command=lambda idx=i: [self.save_state(), self.toggle_scale_note(idx)])
            btn.pack(side="left", padx=1); self.scale_key_btns[i] = btn
        self.refresh_keyboard_colors()

    def toggle_scale_note(self, i): self.custom_scale[i] = not self.custom_scale[i]; self.refresh_keyboard_colors(); self.draw_sequencer(self.pause_elap)
    def refresh_keyboard_colors(self):
        for i, btn in self.scale_key_btns.items(): 
            is_black = i in [1, 3, 6, 8, 10]
            btn.config(bg="#00FF80" if self.custom_scale[i] else ("#444" if is_black else "#DDD"))

    def refresh_track_ui(self):
        self.knob_refs.clear()
        for w in self.track_inner.winfo_children(): w.destroy()
        for i, t in enumerate(self.tracks):
            bg = "#282828" if i == self.active_track_idx else "#222"
            f = tk.Frame(self.track_inner, bg=bg, pady=8, padx=10, bd=1, relief="ridge"); f.pack(fill="x", pady=4, padx=5)
            f.bind("<Button-1>", lambda e, idx=i: self.select_track(idx))
            tk.Label(f, text=f"T{i+1}", bg=bg, fg=KNOB, font=("Arial", 7, "bold")).pack(side="left")
            self.create_custom_knob(f, i, "vol", "VOL", 0, 2.0, "#00FF80")
            self.create_custom_knob(f, i, "tune", "DAFT", 0, 1.0, "#A040FF")
            self.create_custom_knob(f, i, "transpose", "PITCH", -48, 48, "#FF6464")
            m_v = tk.StringVar(value=self.modes[t['ins_idx']])
            tk.OptionMenu(f, m_v, *self.modes, command=lambda v, idx=i: [self.save_state(), self.set_track_mode(idx, v)]).pack(side="right")
        self.track_canvas.config(scrollregion=self.track_canvas.bbox("all"))

    def draw_sequencer(self, now):
        self.canvas.delete("all"); w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
        if w <= 1 or not self.tracks: return
        dur, rh = self.get_loop_dur(), h / 17
        for i in range(17):
            bg = "#151515" if self.custom_scale[(76-i)%12] else "#080808"
            self.canvas.create_rectangle(0, i*rh, w, i*rh+rh, fill=bg, outline="#222")
        for idx, tr in enumerate(self.tracks):
            is_a = (idx == self.active_track_idx)
            for n in tr['notes']:
                nx, nw, ny = (n['t']/dur)*w, (n.get('d', 0.4)/dur)*w, (76-n['m'])*rh
                outline = "#FFD700" if n is self.selected_note else ("white" if is_a else "#333")
                self.canvas.create_rectangle(nx, ny+2, nx+nw, ny+rh-2, fill=NOTE if is_a else "#555", outline=outline)
        self.canvas.create_line((now/dur)*w, 0, (now/dur)*w, h, fill="#00FF80", width=2)

    def _find_note_at(self, x, y):
        if not self.tracks: return None
        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
        dur, rh = self.get_loop_dur(), h / 17
        for n in self.tracks[self.active_track_idx]['notes']:
            nx, nw, ny = (n['t']/dur)*w, (n.get('d', 0.4)/dur)*w, (76-n['m'])*rh
            if nx <= x <= nx+nw and ny <= y <= ny+rh:
                return n
        return None

    def on_canvas_click(self, e):
        if not self.tracks: return
        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
        dur = self.get_loop_dur()
        clicked_note = self._find_note_at(e.x, e.y)
        if clicked_note and (e.state & 0x0004):
            click_time = (e.x / max(1, w)) * dur
            split_offset = click_time - clicked_note['t']
            if 0.05 < split_offset < clicked_note.get('d', 0.4) - 0.05:
                self.save_state()
                original_dur = clicked_note.get('d', 0.4)
                clicked_note['d'] = split_offset
                self.tracks[self.active_track_idx]['notes'].append({
                    't': clicked_note['t'] + split_offset,
                    'm': clicked_note['m'],
                    'd': original_dur - split_offset
                })
            self.draw_sequencer(self.pause_elap)
            return
        if clicked_note:
            self.selected_note = clicked_note
            nx = (clicked_note['t']/dur)*w
            nw = (clicked_note.get('d', 0.4)/dur)*w
            if abs(e.x - (nx + nw)) <= 6:
                self.save_state()
                self.drag_note = clicked_note
                self.drag_start_x = e.x
                self.drag_start_dur = clicked_note.get('d', 0.4)
            self.draw_sequencer(self.pause_elap)
            return
        self.selected_note = None
        self.pause_elap = (e.x / max(1, w)) * dur
        if self.playing: self.start_t = time.time() - self.pause_elap
        self.draw_sequencer(self.pause_elap)

    def on_canvas_drag(self, e):
        if not self.drag_note: return
        w = max(1, self.canvas.winfo_width())
        dur = self.get_loop_dur()
        delta = (e.x - self.drag_start_x) / w * dur
        new_dur = max(0.05, self.drag_start_dur + delta)
        self.drag_note['d'] = new_dur
        self.draw_sequencer(self.pause_elap)

    def on_canvas_release(self, e):
        self.drag_note = None

    def on_canvas_right_down(self, e):
        self.duplicate_note = self._find_note_at(e.x, e.y)
        if self.duplicate_note:
            if self.duplicate_after_id:
                self.root.after_cancel(self.duplicate_after_id)
            self.duplicate_after_id = self.root.after(400, self._duplicate_held_note)

    def on_canvas_right_up(self, e):
        if self.duplicate_after_id:
            self.root.after_cancel(self.duplicate_after_id)
        self.duplicate_after_id = None
        self.duplicate_note = None

    def _duplicate_held_note(self):
        if not self.duplicate_note or not self.tracks: return
        self.save_state()
        tr = self.tracks[self.active_track_idx]
        cloned = copy.deepcopy(self.duplicate_note)
        tr['notes'].append(cloned)
        self.selected_note = cloned
        self.draw_sequencer(self.pause_elap)
        self.duplicate_after_id = None
        self.duplicate_note = None

    def on_canvas_scroll(self, e):
        if not self.tracks or self.active_track_idx >= len(self.tracks): return
        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
        dur, rh = self.get_loop_dur(), h / 17
        found_note = None
        for n in self.tracks[self.active_track_idx]['notes']:
            nx, nw, ny = (n['t']/dur)*w, (n.get('d', 0.4)/dur)*w, (76-n['m'])*rh
            if nx <= e.x <= nx+nw and ny <= e.y <= ny+rh:
                found_note = n; break
        if found_note:
            self.save_state()
            delta = 1 if (e.delta > 0 or getattr(e, 'num', 0) == 4) else -1
            found_note['m'] = max(0, min(127, found_note['m'] + delta))
            self.draw_sequencer(self.pause_elap)

    def _on_mousewheel(self, e): 
        if self.knob_hovered in self.knob_updates:
            delta = 1 if (e.delta > 0 or getattr(e, 'num', 0) == 4) else -1
            self.knob_updates[self.knob_hovered]((delta) * 0.05)
        elif self.tracks:
            delta = -1 if (e.delta > 0 or getattr(e, 'num', 0) == 4) else 1
            self.track_canvas.yview_scroll(delta, "units")

    def set_track_mode(self, i, v): self.tracks[i]['ins_idx'] = self.modes.index(v); self.refresh_track_ui()
    def select_track(self, i): self.active_track_idx = i; self.refresh_track_ui()
    def key_down(self, e):
        if e.char in KEY_MAP: self.trigger_note(KEY_MAP[e.char])
        elif e.char.lower() == 'r': self.start_mic_recording() if not self.is_recording else self.stop_mic_recording()
    
    def add_track(self, is_v): 
        self.save_state(); self.tracks.append({'notes':[], 'vol':0.8, 'transpose':0, 'tune':0, 'ins_idx': 5 if is_v else 0})
        self.active_track_idx = len(self.tracks)-1; self.refresh_track_ui()

    def remove_track(self):
        if len(self.tracks) > 1: 
            self.save_state(); self.tracks.pop(self.active_track_idx)
            self.active_track_idx = max(0, self.active_track_idx-1); self.refresh_track_ui(); self.draw_sequencer(self.pause_elap)

    def duplicate_track(self): self.save_state(); self.tracks.append(copy.deepcopy(self.tracks[self.active_track_idx])); self.active_track_idx = len(self.tracks)-1; self.refresh_track_ui()
    def delete_selected_notes(self): self.save_state(); self.tracks[self.active_track_idx]['notes'] = []; self.draw_sequencer(self.pause_elap)

if __name__ == "__main__":
    root = tk.Tk()
    app = VoiceRecorderApp(root)
    root.mainloop()
